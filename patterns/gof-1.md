---
layout: default
title: Структурные шаблоны проектирования
---

# Структурные шаблоны проектирования

## 1. Адаптер (Adapter)

Что это: структурный шаблон проектирования, предназначенный для организации использования функций объекта, недоступного для модификации, через специально созданный интерфейс.  

Когда это использовать:

- Нужно использовать класс, который вызывает метод через интерфейс, причем необходимо использовать его вместе с классом, который не реализует этот интерфейс. Изменение класса таким образом, чтобы он реализовывал интерфейс, неприемлемо по двум причинам.

1. Отсутствует исходный код для класса.
2. Класс является классом общего назначения и не подходит для реализации интерфейса специального назначения.

-  Нужно динамически определять, какие методы другого объекта вызывает этот объект, причем объект ничего не должен знать о классе другого объекта.

.. Когда не нужно это использовать

.. image:: https://upload.wikimedia.org/wikipedia/ru/thumb/0/04/Adapter_pattern.svg/627px-Adapter_pattern.svg.png

## 2. Фасад (Facade)

Что это: Структурный шаблон проектирования, упрощающий доступ к связному набору объектов, представляя для связи с этим набором объектов один объект, который используется всеми другими объектами, не принадлежащими этому набору.

Когда это использовать:

- Между классами, реализующими абстракцию, и соответствующими клиентскими классами существует множество зависимостей. Эти зависимости очень усложняют клиентские классы.
- Нужно упростить клиентские классы, поскольку более простые классы позволяют делать меньше ошибок.
- Кроме того, чем проще клиенты, тем требуются меньшие усилия для использования классов, реализующих абстракцию, при их изменении.
- Проектируются классы для многоуровневого приложения. Необходимо свести к минимуму количество классов, доступных с соседних уровней.

.. Когда не нужно это использовать

.. image:: https://upload.wikimedia.org/wikipedia/ru/2/2f/Facade.gif

## 3. Декоратор (Decorator)

Что это: Шаблон Decorator расширяет функциональные возможности объекта, используя прозрачный для его клиентов способ: он реализует тот же самый интерфейс, что и исходный класс, и делегирует исходному классу операции.

Когда его использовать:

- Нужно расширить функциональные возможности класса, однако существуют причины, не позволяющие выполнить расширение при помощи наследования.
- Существует необходимость в динамическом расширении функциональных возможностей объекта.

Когда его не использовать:

- Из-за своей гибкости объекты декораторов более подвержены ошибкам, чем унаследованные объекты. Например, существует вероятность такой комбинации объектов-оберток, при которой они не будут работать, или возможно создание циклических ссылок между объектами декораторов.
- Шаблон Decorator затрудняет использование уникальности объектов для идентификации объектов сервиса, поскольку скрывает объекты сервиса за объектами-декораторами.

.. image:: https://upload.wikimedia.org/wikipedia/ru/0/00/Decorator_template.png

## 4. Компоновщик (Composite)

Что это: Шаблон Composite позволяет создавать сложные объекты посредством рекурсивного объединения похожих объектов в виде дерева.

Когда его использовать:

- Есть сложный объект, который нужно представить в виде иерархии объектов, представляющей отношение «часть - целое».
- Нужно свести к минимуму сложность иерархии «часть - целое» , оставляя минимальное количество различных дочерних объектов, о которых должны быть осведомлены объекты дерева.
- Не предъявляется никаких требований к большей части объектов из иерархии по их различию.

.. Когда его не использовать

.. image:: https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/Composite_UML_class_diagram_%28fixed%29.svg/600px-Composite_UML_class_diagram_%28fixed%29.svg.png

## 5. Мост (Bridge)

Что это: Структурный шаблон проектирования, используемый в проектировании программного обеспечения чтобы «разделять абстракцию и реализацию так, чтобы они могли изменяться независимо».

Когда его использовать:

- Если иерархии абстракций и иерархии их реализаций объединяются в единую иерархию классов, то классы, использующие такие классы, будут связаны с определенной реализацией абстракции. Изменение реализации соответствующей абстракции не должно приводить к изменению классов, использующих эту абстракцию.
- Нужно многократно использовать логику, общую для различных реализаций абстракции. Обычный способ сделать логику многократно используемой состоит в том, чтобы инкапсулировать ее в отдельном классе.
- Необходимо иметь возможность создавать новую реализацию абстракции, не выполняя повторную реализацию общей логики абстракции.
- Нужно расширить общую логику абстракции путем написания одного нового класса, а не путем написания нового класса для каждой комбинации: «базовая абстракция - ее реализации».
- Если есть возможность, несколько абстракций должны совместно использовать одну и ту же реализацию.

.. Когда его не использовать

.. image:: https://upload.wikimedia.org/wikipedia/ru/8/81/Bridgeuml.gif

## 6. Приспособленец (Flyweight)

Что это: Если экземпляры класса, содержащие одинаковую информацию, Могут использоваться как взаимозаменяемые, то шаблон Flyweight позволяет программе избежать издержек, связанных с созданием множества экземпляров, содержащих одинаковую информацию, применяя механизм совместного использования одного экземпляра.

Когда его использовать:

- Есть приложение, которое использует большое количество одинаковых объектов.
- Необходимо уменьшить значительные затраты памяти на поддержку большого количества похожих объектов.
- Программа не полагается на уникальность объектов любых объектов, которые она, по желанию разработчика, должна совместно использовать. Если программа применяет различные объекты в разных контекстах, то сущесгвует возможность различать контексты, используя уникальность объектов. Если различные контексты совместно используют одни и те же объекты, то эти контексты уже нельзя отличать при помощи уникальности объектов.
- Представление похожих вещей похожими объектами требует большего объема памяти, чем представление похожих вещей при помощи одного и того же объекта. Чем больше вещей могут быть представлены одним и тем же объектом, тем значительнее экономия памяти.
- Применяя объекты-приспособленцы совместного использования, можно значительно уменьшить количество объектов, находящихся в памяти.

Когда его не использовать:

- Шаблон Flyweight усложняет програму. Основными источниками дополнительной сложности являются объекты-приспособленцы со своими внешними состояниями, а также управление многократным использованием объектов-приспособленцев.
- Шаблон Flyweight может привести к увеличению времени работы просраммы так как доступ объекта к внешнему состоянию требует больших усилий, чем доступ к внутреннему состоянию.
- Обычно можно различать сущности по объектам, которые их представляют. Шаблон Ayweight делает это невозможным, так как с его помощью множество сущностей представляется в конечном счете одним и тем же объектом.
- Совместно используемые объекты-приспособленцы не могут содержать ссылок на родителей.
- Из-за сложности, связанной с использованием шаблона Ayweight, и ограничений, накладываемых им на организацию классов, следует рассматривать шаблон Flyweight как оптимизацию, при меняемую после разработки остальной части проекта.

.. image:: https://upload.wikimedia.org/wikipedia/ru/e/ee/Flyweight.gif

## 7. Прокси (Proxy)

Что это: Cтруктурный шаблон проектирования, который предоставляет объект, который контролирует доступ к другому объекту, перехватывая все вызовы (выполняет функцию контейнера).

Когда его использовать:

- Когда требуется сделать отложенное инстанциирование сложного объекта (создавать объект только тогда когда он потребуется).
- Когда надо добавить дополнительный функционал в объект, обходясь без наследования.

Когда его не использовать:

- Шаблон незначительное замедляет отклик от объекта, так как упаковывает его в контейнер.

.. image:: https://upload.wikimedia.org/wikipedia/ru/0/08/Proxy_patt.gif
