---
layout: default
date: 0001-01-01
title: Поведенческие паттерны (Behavioral patterns)
---
# Поведенческие паттерны (Behavioral patterns)

Поведенческие шаблоны — шаблоны проектирования, определяющие алгоритмы и способы реализации взаимодействия различных объектов и классов.

## 1. Стратегия (Strategy)

Что это:
> Шаблон проектирования, предназначенный для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости. Это позволяет выбирать алгоритм путём определения соответствующего класса. Шаблон Strategy позволяет менять выбранный алгоритм независимо от объектов-клиентов, которые его используют.

Когда применять:
- По типу клиента (или по типу обрабатываемых данных) выбрать подходящий алгоритм, который следует применить. Если используется правило, которое не подвержено изменениям, нет необходимости обращаться к данному шаблону.

Участники:
- Класс Strategy определяет, как будут использоваться различные алгоритмы.
- Конкретные классы ConcreteStrategy реализуют эти различные алгоритмы.
- Класс Context использует конкретные классы ConcreteStrategy посредством ссылки на конкретный тип абстрактного класса Strategy. Классы Strategy и Context взаимодействуют с целью реализации выбранного алгоритма (в некоторых случаях классу Strategy требуется посылать запросы классу Context). Класс Context пересылает классу Strategy запрос, поступивший от его класса-клиента.
![Strategy](https://upload.wikimedia.org/wikipedia/ru/4/4c/Strategy_pattern.PNG)

## 2. Состояние (State)

Что это:
> Используется в тех случаях, когда во время выполнения программы объект должен менять своё поведение в зависимости от своего состояния.

Когда применять:
- Когда поведение некоторого объекта зависит от его внутреннего состояния. Хорошо подходит для описания состояний и переходов между окнами в UI.

Когда не применять:
- Не стоит применять, если у вас очень малое количество состояний, так как нагромождение паттернов усложняет систему.

Участники:
- Context - класс чье поведение зависит от его внутреннего состояния
- State - интерфейс определяющий поведение объекта
- ConcreteStateA … ConcreteStateB - конкретные классы, представляющие собой состояния и реализующие интерфейс State тем или иным образом. Так же могут осуществлять переход объекта Context из одного состояния в другое.

Примечание:
> Диаграмма классов здесь такая же в “Стратегии”, но несмотря на это данные паттерны решают разные задачи.

## 3. Наблюдатель (Observer)

Что это:
> Создает схему “издатель”-“подписчики”. То есть объекты “подписчики” подписываются на получение уведомлений или событий от объекта “издатель”, который, собственно, эти данные рассылает своим подписчикам. Очень распространенный шаблон, идеи заложенные в него получили большое распространение в реактивном программировании, которое становится весьма популярным в последнее время.

Участники:
- Observable - интерфейс издателя, определяет возможности добавления, удаления и оповещения подписчиков
- Observer - интерфейс подписчика, определяет метод, который вызывается издателем при оповещении, то есть обработку оповещения
- ConcreteObservable - конкретный класс издателя, хранит в себе коллекцию подписчиков, вызывает на каждом из них метод обработки оповещения при изменении своего состояния.
- ConcreteObserverA…ConcreteObserverB - конкретные классы подписчиков, обрабатывают полученные данные от издателя.

![Observer](https://upload.wikimedia.org/wikipedia/commons/b/bd/Observer_UML_smal.png)

## 4. Шаблонный метод (Template method)

Что это:
> Определяет некоторый алгоритм, шаги которого могут подменены или реализованы в классах.

Когда применять
- Когда у вас некоторый алгоритм, который выполняется в нескольких местах, причем с некоторыми различиями.

Когда не применять
- Данный паттерн следует применять с осторожностью, так как иногда стоимость объединения схожих операций и вынесение общих частей в абстракцию может иметь большую цену. Так как поддерживать и понимать такие абстракции довольно сложно.

Участники:
- Abstract Class - определяет абстрактные операции, которые реализуются в наследниках и операции, которые общие для всех наследников, которые подменять не надо.
- ConcreteClass - реализует замещаемые операции нужным для него способом.

![Template method](https://upload.wikimedia.org/wikipedia/commons/thumb/5/52/Template_Method_UML.svg/400px-Template_Method_UML.svg.png)

## 5. Итератор (Iterator)

Что это:
> Предоставляет последовательный доступ к элементам объекта-агрегата. Например, такими объектами могут быть различные коллекции (массивы, листы, хеш-таблицы, множества, деревья и т.д.). Позволяет перебрать элементы агрегата, не зная о его типе. Как правило, данный паттерн вынесен в стандартную библиотеку практически во всех языках программирования.

Когда применять:
- Когда вам необходимо перебрать элементы некоторого объекта-агрегата, инкапсулировав его тип и скрыв сам механизм перебора.

Участники:
- Aggregate - интерфейс объекта-агрегатора, определяет возможность создания итератора
- Client - клиентский код
- ConcreteAggregate - конкретный объект-агрегатор, который создаёт конкретный итератор, который перебирает его элементы.
- Iterator - интерфейс, определяет функционал итератора, позволяющий перебрать элементы объекта-агрегата.
- ConcreteIterator - конкретный итератор, который перебирает элементы определенного объекта-агрегата.

![Iterator](https://upload.wikimedia.org/wikipedia/commons/c/c5/W3sDesign_Iterator_Design_Pattern_UML.jpg)

## 6. Null объект (Null object)

Что это:
> Представляет собой объект, который представляет собой значение null. Обеспечивает “null-safety”, то есть гарантию того, что программа не упадет с ошибкой во время выполнения из-за получения null в каком-нибудь объекте. В последнее время идет тендеция к обеспечению null-safety на уровне языка или в стандартной библиотеке, например, в некоторых языках есть так называемая конструкция Option (Java, Scala), которая, по сути, и реализует данный паттерн, только путем композиции, а не наследования. В некоторых других языках (например Swift, Kotlin и в некоторых других) null-safety вынесен в синтаксис языка, где все объекты по умолчанию не могут быть nullable и необходимо специальным образом помечать возможность того, что некоторый объект может быть null. Таким образом проверка на null-safety происходит на этапе компиляции и, соответственно, возможность ошибки программы во время выполнения из-за получения null исключается. Также, если смотреть на этот паттерн со стороны коллекций, то вместо возвращения null, лучше возвращать пустые коллекции.

Когда применять
- Когда вы используете язык, в котором отсутствуют механизмы обеспечения null-safety и хотите обезопасить себя от возможности ошибок связанных с null, рекомендуется найти библиотеки, в которых этот паттерн уже реализован.

Участники:
- Client - клиентский код
- AbstractEntity - абстрактный класс, задающий поведение, которое мы хотим защитить от null
- RealEntity - конкретная сущность, реализующая поведение.
- NullEntity - null-object - пустышка, которая безопасным образом реализует отсутствие объекта.

![Null object](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4a/Null_Object.svg/600px-Null_Object.svg.png)

## 7. Команда (Command, Action)

Что это:
> Паттерн, в котором объект инкапсулирует всю информацию необходимую для совершению действия. Данный паттерн весьма широко распространен, особенно в параллельном программировании, когда создаются некоторые задачи (команды, command), которые должны быть выполнены параллельно с вызывающим потоком, эти задачи “скармливаются” специальному объекту (invoker), который обеспечивает выполнение этих команд. В данном паттерне также можно реализовать отмену и просмотр истории команд.

Когда использовать:
- Когда необходимо обеспечить выполнение некоторых действий (команд) в некотором сервисе.

Схема

Участники:
- Command - интерфейс для команды, как правило имеет один метод execute, может иметь дополнительные методы для отмены команды и других действий.
- ConcreteCommand - конкретная команда. Знает о receiver и вызывает метод на нем. Хранит в себе аргументы для метода.
- Receiver - объект, на котором вызываются команды.
- Invoker - знает о том как вызывать команды. Не знает о том как устроена конкретная команда, оперирует ими через общий интерфейс для команд.
- Client - клиентский код, оперирует командами и invoker’ом. Для выполнения команды создаёт команду и передаёт её invoker’у.

## 8. Медиатор (Mediator)

Что это:
> Обеспечивает взаимодействие множества объектов, формируя при этом слабую связанность и избавляя объекты от необходимости явно ссылаться друг на друга.

Когда использовать:
- Когда нужно обеспечить взаимодействие множества объектов, сформировав при этом слабую связанность и избавив объекты от необходимости явно ссылаться друг на друга.

Участники:
- Mediator - определяет интерфейс для обмена информацией с объектами Colleague
- ConcreteMediator - координирует действия объектов Colleague. Каждый класс Colleague знает о своем объекте Mediator, все Colleague обмениваются информацией только с Mediator, при его отсутствии им пришлось бы обмениваться информацией напрямую.
- Colleague посылают запросы посреднику и получают запросы от него. Mediator реализует кооперативное поведение, пересылая каждый запрос одному или нескольким Colleague.

Схема

## 9. Цепочка обязанностей (Chain of responsibility)

Предназначен для организации в системе уровней ответственности.

Когда применять:
- в разрабатываемой системе имеется группа объектов, которые могут обрабатывать сообщения определенного типа;
- все сообщения должны быть обработаны хотя бы одним объектом системы;
- сообщения в системе обрабатываются по схеме «обработай сам либо перешли другому», то есть одни сообщения обрабатываются на том уровне, где они получены, а другие пересылаются объектам иного уровня.

Схема

Участники:
- Handler - интерфейс, задающий некоторый функционал
- ConcreteHandler - конкретный handler, реализует этот функционал, хранит в себе ссылку на следующий handler, которому перешлет свою работу, если не сделает ее сам.

## 10. Интерпретатор (Interpreter)

Что это:
> Определяет как нужно выполнять (вычислять, evaluate) предложения некоторого языка. Базовая идея заключается в том, что для каждого токена (выражение, expression) (терминального или нетерминального) в специализированном компьютерном языке имеется отдельный класс. Синтаксическое дерево предложения - реализация паттерна Компоновщик/Composite, и используется для выполнения/вычисления этого предложения. Данный паттерн не определяет как нужно парсить предложение - это работа другой системы.

Когда применять
- Когда вы создаете новый или создаете свою реализацию некоторых компьютерных языков.

Схема

Участники:
- Client - клиентский код
- Context - текущий контекст языка - например соответствия имен переменных к их значениям
- AbstractExpression - интерфейс для всех токенов, задающий возможность интерпретации
- TerminalExpression - терминальное выражение
- NonterminalExpression - нетерминальное выражение

Примечание: понятия терминальные и нетерминальные выраженияотносятся к науке формальных языков, на нашей кафедре есть этот предмет где все это изучается.

## 11. Посетитель (Visitor)

Что это:
> Описывает операцию, которая выполняется над объектами других классов. При изменении visitor нет необходимости изменять обслуживаемые классы.

Когда применять:
- Когда необходимо для ряда классов сделать похожую (одну и ту же) операцию для некоторых классов и вы не можете или не хотите вносить этот функционал в их код.

Когда не применять:
- Если обслуживаемые классы могут сильно поменяться, их код часто меняется или, если интерфейс у этих классов недостаточно эффективен для использования извне.

Схема

Участники:
- Client - клиентский код
- Visitor - интерфейс, описывает возможность операции над обслуживаемым классом
- ConcreteVisitor - конкретный visitor, реализует некоторую операцию над обслуживаемым классом
- Element - базовый интерфейс иерархии обслуживаемых классов, описывает возможность быть посещенным, то есть быть выполненным под некоторой операцией класса Visitor
- ConcreteElement - конкретный обслуживаемый класс

## 12. Хранитель (Memento)

Что это:
> Позволяет, не нарушая инкапсуляцию, зафиксировать и сохранить внутреннее состояние объекта так, чтобы позднее восстановить его в это состояние.

Когда применять
- Когда необходимо сохранить снимок (snapshot) состояния объекта (или его части) для последующего восстановления
- Прямой интерфейс получения состояния объекта раскрывает детали реализации и нарушает инкапсуляцию объекта

Схема

Участники
- Originator - “Создатель”
- Caretaker - “Опекун”
- Memento - “Хранитель”

Шаблон Хранитель используется двумя объектами: “Создателем” (originator) и “Опекуном” (caretaker). “Создатель” - это объект, у которого есть внутреннее состояние. Объект “Опекун” может производить некоторые действия с “Создателем”, но при этом необходимо иметь возможность откатить изменения. Для этого “Опекун” запрашивает у “Создателя” объект “Хранителя”. Затем выполняет запланированное действие (или последовательность действий). Для выполнения отката “Создателя” к состоянию, которое предшествовало изменениям, “Опекун” возвращает объект “Хранителя” его “Создателю”. “Хранитель” является непрозрачным (т.е. таким, который не может или не должен изменяться “Опекуном”).
