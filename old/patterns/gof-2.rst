Порождающие шаблоны проектирования
==================================

1. Одиночка (Singleton)
-----------------------

Что это: Порождающий шаблон проектированя гарантирующий, что создается только один экземпляр некоторого класса. Все объекты, использующие экземпляр этого класса, имеют дело с одним и тем же экземпляром.

Когда это использовать:

- Должен существовать по крайней мере один экземпляр некоторого класса. Даже если методы класса не используют данных экземпляра или используют только статические данные, может понадобиться экземпляр такого класса по разным причинам. Некоторые самые общие причины могут заключаться в том, что нужен экземпляр для передачи параметра методу другого класса или необходимо иметь косвенный доступ к классу, через интерфейс.
- Не должно быть более одного экземпляра класса. Это может объясняться тем, что нужно иметь только один источник некоторой информации. Например, чтобы был единственный объект, который отвечает за генерирование последовательности порядковых номеров.
- Один экземпляр класса должен быть доступен для всех клиентов этого класса.

Когда его не использовать:

- Создание объекта не требует больших затрат, но он занимает большой объем памяти или непрерывно на протяжении всего своего времени жизни использует другие ресурсы.

.. image:: https://upload.wikimedia.org/wikipedia/commons/d/d7/Singleton_classdia.png

2. Прототип (Prototype)
-----------------------

Что это: Порождающий шаблон проектирования позволяющий создавать специальные объекты, ничего точно не зная об их классе или деталях их создания.

Когда это использовать:

- Когда надо избежать дополнительных усилий по созданию объекта стандартным путём (имеется в виду использование конструктора, так как в этом случае также будут вызваны конструкторы всей иерархии предков объекта), когда это непозволительно дорого для приложения.
- Чтобы избежать наследования создателя объекта (object creator) в клиентском приложении, как это делает паттерн abstract factory.
- Различные объекты, которые должны создаваться системой, могут быть экземплярами одного и того же класса и отличаться друг от друга информацией, заключенной в них.

Когда его не использовать:

- Когда нужно создать экзепляры разных классов в зависимости от состояния системы в целом, этот паттерн не подойдет (лучше использовать абстрактную фабрику)

.. image:: https://upload.wikimedia.org/wikipedia/ru/2/25/Prototype.gif

3. Строитель (Builder)
----------------------

Что это: Порождающий шаблон проектирования предоставляет способ создания составного объекта. При этом клиент избавляется от информации о построения объекта.

Когда его использовать:

- Программа должна иметь возможность создавать многочисленные внешние представления одних и тех же данных.
- Классы, содержащие в себе данные, не должны зависеть от какого-либо внешнего представления этих данных и от классов, участвующих в их создании. Если классы, инкапсулирующие в себе данные, не зависят от внешних представлений данных, то изменения классов, отвечающих за внешнее представление этих данных, не потребуют изменения классов, отвечающих за их содержимое.
- Классы, отвечающие за создание внешних представлений данных, не зависят от классов, инкапсулирующих их в себе. Их экземпляры могут работать с любым, предоставляющим содержание, объектом, ничего о нем не зная.

Когда его использовать:

- Этот паттерн не используется если необходимо создавать объекты различных классов.

.. image:: https://upload.wikimedia.org/wikipedia/ru/2/28/Builder.gif

4. Фабричный метод (Factory Method)
-----------------------------------

Что это: Порождающий шаблон проектирования, предоставляющий подклассам интерфейс для создания экземпляров некоторого класса. В момент создания наследники могут определить, какой класс создавать. Иными словами, Фабрика делегирует создание объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком уровне.

Когда это использовать:

- Когда нужно создать объект, представляюший внешние данные, или обработать какое-то внешнее событие. Тип объекта зависит от содержимого внешних данных или от типа события. Необходимо, чтобы ни источник данных, ни источник события, ни клиенты события не были осведомлены о реальном типе создаваемого объекта. В таком случае инкапсулируют решение о том, какой класс объекта создавать.
- Класс должен иметь возможность инициировать создание объектов, не будучи каким-либо образом зависимым от класса создаваемого объекта.
- Считается, что класс может инстанциировать набор классов, который может быть динамичным и изменяться по мере того, как становятся доступными новые классы.

.. Когда его не использовать

.. https://upload.wikimedia.org/wikipedia/ru/f/f0/FactoryMethodPattern.png

5. Абстрактная фабрика (Abstract Factory)
-----------------------------------------

Что это: Порождающий шаблон проектирования, предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов. Шаблон реализуется созданием абстрактного класса Factory, который представляет собой интерфейс для создания компонентов системы (например, для оконного интерфейса он может создавать окна и кнопки). Затем пишутся классы, реализующие этот интерфейс.

Когда это использовать:

- Если задан набор связанных интерфейсов, то шаблон Abstract Factory предоставляет способ создания объектов, реализующих эти интерфейсы, из соответствующего набора конкретных классов.
- Шаблон Abstract Factory может быть полезен в том случае, когда программа должна работать с разнообразными сложными внешними реальными объектами, например, системами управления окнами, обладающими похожей функциональностью.
- Клиентские классы не зависят от конкретных классов элементов окон, которые они используют.
- Добавление (в отличие от написания) классов для работы с дополнительными продуктами осуществляется просто. Обычно на класс конкретного объекта-фабрики ссылка должна делаться только в одном месте. Кроме того, несложно заменить конкретный объект-фабрику, используемый для работы с определенным продуктом.

Когда это не использовать:

- Главный недостаток шаблона Abstract Factory в том, что при взаимодействии с продуктом может понадобиться большая работа по написанию нового набора классов. Значительных усилий требует также расширение набора характеристик, которые существующий набор классов способен реализовать.
- Клиентские объекты могут потребовать, чтобы создаваемые классы были организованы в виде иерархии, которая обслуживает потребности клиентских объектов. Шаблон Abstract Factory сам по себе не подходит для решения этой задачи, так как он требует организации конкретных классов в виде иерархии классов, не зависящей от клиентских объектов.

.. image:: https://upload.wikimedia.org/wikipedia/commons/thumb/9/9d/Abstract_factory_UML.svg/677px-Abstract_factory_UML.svg.png
